<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <em>你好</em>
  <i>nihao</i>
  <strong>hello</strong>
  <b>你好</b>
  
  <script>
    /* 
      document.documentElement 得到的是页面的根元素
        <html lang="zh">
        <head>...</head>
        <body>...</body>
        </html>
      document.documentElement.style 得到的是根元素的样式对象
        CSSStyleDeclaration{......} 
      document.body 得到的是 body 元素
        <body>...</body>
    */
    console.log('document.documentElement:', document.documentElement)
    console.log('document.documentElement.style:', document.documentElement.style)
    console.log('document.body:', document.body)


    /* 
      【数组的方法，forEach(), map(), filter()等会不会改变原数组】
      如果在遍历方法内对原数组进行了相关的改变操作，每次遍历得到且传入的参数为引用数据类型的话，会改变原数组，例如：map(item => {} )此处的item为引用数据类型；如果每次遍历得到且传入的参数为基本数据类型的话，则不会改变原数组，例如：map(item => {} )此处的item为基本数据类型。
     */
    let potato = [
      {id: 1, w: 10},
      {id: 2, w: 30},
      {id: 3, w: 40},
      {id: 4, w: 20},
      {id: 5, w: 50}
    ]
    // let potato = [
    //   {id: 1, w: {a: "aa"}},
    //   {id: 2, w: {a: "bb"}},
    //   {id: 3, w: {a: "cc"}},
    //   {id: 4, w: {a: "dd"}},
    //   {id: 5, w: {a: "ee"}}
    // ]

    // let potato = [1, 2, 3, 4]

    // let newArr = potato.forEach(item => { 
    //   item.w += 5
    //   // return item.id
    // })
    // console.log('potato', potato) // 改变后的
    // console.log('newArr:', newArr) // undefined

    // let res = potato.map(({w}) => {
    //   w.a += 5
    //   return {w: w.a}
    // })
    // console.log('potato::', potato) 
    // console.log('res::', res)

    // let newArr = potato.filter(item => {
    //   item += 5
    //   return item > 8
    // })
    // console.log('potato:', potato)
    // console.log('newArr:', newArr)


    /* 
      【对象的拷贝】
      1.对象的方法（assign()）或者扩展运算符（...）复制的对象，得到的两个对象是false,且第一层value为基本数据类型的话，类似于深拷贝，改变一个，另一个对象不会变化，但是如果value是引用类型，改变这个引用类型里面的值，那个复制的对象对应的值也会变。也就是说对象的方法（assign()）或者扩展运算符（...）只能进行对象第一层的深拷贝，如果对象第一层的value值为引用类型，那么这个value的拷贝就无法实现深拷贝,所以从层次来说，严格意义上它们还是浅拷贝。
      2.通过JSON.parse(JSON.stringify())的方法拷贝的对象是深拷贝。
     */
    let obj1 = {
      a: 1,
      b: 2,
      c: {d: 4, e: 5}
    }
    let obj2 = JSON.parse(JSON.stringify(obj1))
    console.log(obj1 === obj2) // false
    obj1.a = 11
    console.log(obj2.a) // 1
    console.log(obj2.c === obj1.c) // false
    obj1.c.d = 22
    console.log(obj2.c.d) // 4

    // let obj2 = Object.assign({}, obj1)
    // console.log(obj1 === obj2) // false
    // obj1.a = 11
    // console.log(obj2.a) // 1
    // console.log(obj2.c === obj1.c) // true
    // obj1.c.d = 22
    // console.log(obj2.c.d) // 22

    // let obj2 = {...obj1}
    // console.log(obj1 === obj2) // false
    // obj1.a = 11
    // console.log(obj2.a) // 1
    // console.log(obj2.c === obj1.c) // true
    // obj1.c.d = 22
    // console.log(obj2.c.d) // 22


    /*
      【setTimeout()方法中第一个参数函数的书写方式】
      1.加引号（setTimeout("func()",1000)）,且这个func会在全局找
      2.不加引号（setTimeout(func,1000)），这个func会在局部找
      3.setTimeout(func(),1000),不会延时，func函数会立即执行
    */
    var userName = '张三'
    function hello(name){
      console.log('hello'+name)
      console.log('this:',this)
    }
    // const hello = (name)=>{
    //   console.log('hi,hello'+name)
    //   console.log('this:',this)
    // }
    // setTimeout(hello(userName),3000) // 立即执行，打印‘hello张三’，this打印为Window，不会等到3秒
    // setTimeout('hello(userName)',3000) // 3秒后执行，打印‘hello张三’，this打印为Window
    // setTimeout(hello,3000) // 3秒后执行，打印‘helloundefined’，this打印为Window

    // var a = 123
    // setTimeout(function(a){
    //   console.log('a:',a) // 3秒后打印结果 undefined
    // },3000)

    // 通过 setTimeout的第三个参数传参
    // var a = 123
    // setTimeout(function(b){
    //   console.log('b:',b) // 3秒后打印结果 b:123, 形参b也可以接收到传进去的a
    //   console.log('a:',a) // 3秒后打印结果 a:123, 可以直接打印传进去的变量a
    // },3000,a)

    // var a = 123
    // setTimeout(function(b){
    //   console.log('this:',this)
    //   console.log('b:',b) // 3秒后打印结果 b:123
    // }.bind(null,a),3000)

    var a = 123
    setTimeout(function(){
      console.log('a:',a) // 3秒后打印结果 a:123
    },3000)

    window.onload = function(){
      var local = function(){
        function global(){
              console.log("这是局部变量！");
          }
          setTimeout("global()",1000);//"这是全局变量！"
          setTimeout(global,1000);//"这是局部变量！"
      };
      local();
    };
    function global(){
      console.log("这是全局变量！")
    }

  </script>

  
</body>
</html>